

### ObjectAnimator

> start()方法启动
```text
    public void start() {
            AnimationHandler.getInstance().autoCancelBasedOn(this);
            //autoCancelBasedOn 的处理逻辑大致是，如果队列中的动画设置了setAutoCancel(true)，并且
            //与当前要启动的这个属性动画的各方面属性都一致时(包括动画target)，那么队列中的这个动画就是执行cancel()
            //由新启动的这个进行替代
            super.start();//真正的逻辑由基类ValueAnimator.start()执行
        }
```

### AnimationHandler

> 单例模式 ， 为当前应用进程的所有属性动画提供服务

1、数据集的作用
```text
        //提供如下几种动画处理的回调数据集
        private final ArrayMap<AnimationFrameCallback, Long> mDelayedCallbackStartTime =
                new ArrayMap<>();
        private final ArrayList<AnimationFrameCallback> mAnimationCallbacks =
                new ArrayList<>();
        private final ArrayList<AnimationFrameCallback> mCommitCallbacks =
                new ArrayList<>();
        //说明：
        mAnimationCallbacks 是保存实现了 AnimationHandler.AnimationFrameCallback的实例，
        其实就是ValueAnimator对象(ValueAnimator实现了该接口)
```
2、回调接口
```java
    //
    interface AnimationFrameCallback {
            /**
             * Run animation based on the frame time.
             * @param frameTime The frame start time, in the {@link SystemClock#uptimeMillis()} time
             *                  base.
             * @return if the animation has finished.
             */
            boolean doAnimationFrame(long frameTime);
    
            void commitAnimationFrame(long frameTime);
        }
```

```text
    //核心方法作用：
    //1）保存动画的回调实例
    //2）通过编舞者(Choreographer)注册
    public void addAnimationFrameCallback(final AnimationFrameCallback callback, long delay) {
            //当初次使用属性动画或者属性动画数据集中的动画都执行完成后数据集为0时，
            //都会通过
            if (mAnimationCallbacks.size() == 0) {
                getProvider().postFrameCallback(mFrameCallback);
            }
            if (!mAnimationCallbacks.contains(callback)) {
                mAnimationCallbacks.add(callback);
            }
    
            if (delay > 0) {
                mDelayedCallbackStartTime.put(callback, (SystemClock.uptimeMillis() + delay));
            }
        }
        
     //mFrameCallback的定义如下
     //回调到doFrame方法时，就会开始执行动画
     private final Choreographer.FrameCallback mFrameCallback = new Choreographer.FrameCallback() {
             @Override
             public void doFrame(long frameTimeNanos) {
                 doAnimationFrame(getProvider().getFrameTime());
                 if (mAnimationCallbacks.size() > 0) {
                     getProvider().postFrameCallback(this);
                 }
             }
         };
```
```text
    当屏幕刷新时钟脉冲信号触发时，回调到Choreographer 中FrameDisplayEventReceiver的
    onVsync(long timestampNanos, long physicalDisplayId, int frame){
        ...
        Message msg = Message.obtain(mHandler, this);//FrameDisplayEventReceiver 实现了Runnable接口
        msg.setAsynchronous(true);//设置为异步消息
        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);
        //mHandler把消息发送出去，因为该msg存在callback，那么在dispatchMessage分发消息时，就会回调到Runnable的run()方法
        //在FrameDisplayEventReceiver的体现就是会执行run()方法
        ...
    }
    //消息被分发后，回调到
    public void run() {
        mHavePendingVsync = false;
        doFrame(mTimestampNanos, mFrame);
    }
    
    //doFrame方法就是处理各种回调逻辑(动画、屏幕刷新等)
    //对于属性动画这一步我们侧重关注如下
    
    public void doFrame(long frameTimeNanos, int frame){
        ...
        mFrameInfo.markAnimationsStart();
        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);
        doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos);
        
        ...
    }
    
    //doCallbacks根据callbackType从mCallbackQueues数组中取出对应的callback
    public void doCallbacks(int callbackType, long frameTimeNanos){
         callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(
                            now / TimeUtils.NANOS_PER_MS);
         ...
         for (CallbackRecord c = callbacks; c != null; c = c.next) {
             c.run(frameTimeNanos);
         }
    }
    // 进入如下逻辑
    private static final class CallbackRecord {
        public CallbackRecord next;
        public long dueTime;
        public Object action; // Runnable or FrameCallback
        public Object token;
        @UnsupportedAppUsage
        public void run(long frameTimeNanos) {
             //从属性动画的回调注册我们知道，属性动画这里的token就是FRAME_CALLBACK_TOKEN
            if (token == FRAME_CALLBACK_TOKEN) {
                ((FrameCallback)action).doFrame(frameTimeNanos);
                //回调到AnimationHandler的mFrameCallback的doFrame方法
            } else {
                ((Runnable)action).run();
            }
        }
    }
```
进入流程

```text
    private final Choreographer.FrameCallback mFrameCallback = new Choreographer.FrameCallback() {
        @Override
        public void doFrame(long frameTimeNanos) {
            doAnimationFrame(getProvider().getFrameTime());
            if (mAnimationCallbacks.size() > 0) {
                getProvider().postFrameCallback(this);//继续注册下一帧的监听,一直到动画执行完成
            }
        }
    };
    
    private void doAnimationFrame(long frameTime) {
        long currentTime = SystemClock.uptimeMillis();
        final int size = mAnimationCallbacks.size();
        for (int i = 0; i < size; i++) {
            final AnimationFrameCallback callback = mAnimationCallbacks.get(i);
            if (callback == null) {
                continue;
            }
            if (isCallbackDue(callback, currentTime)) {
                callback.doAnimationFrame(frameTime);//回到ValueAnimator的doAnimationFrame，开始动画
                if (mCommitCallbacks.contains(callback)) {
                    getProvider().postCommitCallback(new Runnable() {
                        @Override
                        public void run() {
                            commitAnimationFrame(callback, getProvider().getFrameTime());
                        }
                    });
                }
            }
        }
        cleanUpList();//
    }
    
    //当动画已经执行完毕了动画的回调实例就需要移除，节约空间并保证性能
    private void cleanUpList() {
        if (mListDirty) {
            for (int i = mAnimationCallbacks.size() - 1; i >= 0; i--) {
                if (mAnimationCallbacks.get(i) == null) {
                    mAnimationCallbacks.remove(i);
                }
            }
            mListDirty = false;
        }
    }
```


```text
    public void postFrameCallbackDelayed(FrameCallback callback, long delayMillis) {
        if (callback == null) {
            throw new IllegalArgumentException("callback must not be null");
        }
        postCallbackDelayedInternal(CALLBACK_ANIMATION,
                callback, FRAME_CALLBACK_TOKEN, delayMillis);
    }
```
