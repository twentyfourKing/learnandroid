##  Keyframes 关键帧
```java
    /**
     *  接口 关键帧 ； 作用  用来标记动画的关键值，动画在执行值，根据关键值计算出的值作为动画具体值
     */
    public interface Keyframes extends Cloneable {
        void setEvaluator(TypeEvaluator evaluator);
        Class getType();
        Object getValue(float fraction);
        List<Keyframe> getKeyframes();
        Keyframes clone();
        public interface IntKeyframes extends Keyframes {
            int getIntValue(float fraction);
        }
        public interface FloatKeyframes extends Keyframes {
            float getFloatValue(float fraction);
        }
    }
```

```java
    public abstract class Keyframe implements Cloneable {
        boolean mHasValue;
        boolean mValueWasSetOnStart;
        float mFraction;
        Class mValueType;
        private TimeInterpolator mInterpolator = null;
        public static Keyframe ofInt(float fraction, int value) {
            return new IntKeyframe(fraction, value);
        }
        public static Keyframe ofInt(float fraction) {
            return new IntKeyframe(fraction);
        }
        public static Keyframe ofFloat(float fraction, float value) {
            return new FloatKeyframe(fraction, value);
        }
        public static Keyframe ofFloat(float fraction) {
            return new FloatKeyframe(fraction);
        }
        public static Keyframe ofObject(float fraction, Object value) {
            return new ObjectKeyframe(fraction, value);
        }
        public static Keyframe ofObject(float fraction) {
            return new ObjectKeyframe(fraction, null);
        }
        public boolean hasValue() {
            return mHasValue;
        }
        boolean valueWasSetOnStart() {
            return mValueWasSetOnStart;
        }
        void setValueWasSetOnStart(boolean valueWasSetOnStart) {
            mValueWasSetOnStart = valueWasSetOnStart;
        }
        public abstract Object getValue();
        public abstract void setValue(Object value);
        public float getFraction() {
            return mFraction;
        }
        public void setFraction(float fraction) {
            mFraction = fraction;
        }
        public TimeInterpolator getInterpolator() {
            return mInterpolator;
        }
        public void setInterpolator(TimeInterpolator interpolator) {
            mInterpolator = interpolator;
        }
        public Class getType() {
            return mValueType;
        } 
        @Override
        public abstract Keyframe clone();
    }
```
```text
    //从构建 ObjectAnimator 实例开始分析
    public static ObjectAnimator ofFloat(Object target, String propertyName, float... values) {
        ObjectAnimator anim = new ObjectAnimator(target, propertyName);//1)
        anim.setFloatValues(values);//2)
        return anim;
    }
    //1) 使用私有构造方法创建实例
    private ObjectAnimator(Object target, String propertyName) {
        setTarget(target);
        setPropertyName(propertyName);//1-1)
    }
        //1-1) 
        public void setPropertyName(@NonNull String propertyName) {
            if (mValues != null) {
                PropertyValuesHolder valuesHolder = mValues[0];
                String oldName = valuesHolder.getPropertyName();
                valuesHolder.setPropertyName(propertyName);
                mValuesMap.remove(oldName);
                mValuesMap.put(propertyName, valuesHolder);
            }
            mPropertyName = propertyName;
            mInitialized = false;
        }
        //1-2) 
        public void setProperty(@NonNull Property property) {
            if (mValues != null) {
                PropertyValuesHolder valuesHolder = mValues[0];
                String oldName = valuesHolder.getPropertyName();
                valuesHolder.setProperty(property);
                mValuesMap.remove(oldName);
                mValuesMap.put(mPropertyName, valuesHolder);
            }
            if (mProperty != null) {
                mPropertyName = property.getName();
            }
            mProperty = property;
            mInitialized = false;
        }  
    //2) 设置动画变化的值
    public void setFloatValues(float... values) {
        if (mValues == null || mValues.length == 0) {
            if (mProperty != null) {
                setValues(PropertyValuesHolder.ofFloat(mProperty, values));
            } else {
                setValues(PropertyValuesHolder.ofFloat(mPropertyName, values));//3)
            }
        } else {
            super.setFloatValues(values);
        }
    }
    //3) 
    public static PropertyValuesHolder ofFloat(String propertyName, float... values) {
        return new FloatPropertyValuesHolder(propertyName, values);
    }
    // FloatPropertyValuesHolder
    public void setFloatValues(float... values) {
        super.setFloatValues(values);//4)
        mFloatKeyframes = (Keyframes.FloatKeyframes) mKeyframes;
    }
    //4)
    public void setFloatValues(float... values) {
        mValueType = float.class;
        mKeyframes = KeyframeSet.ofFloat(values);//创建关键帧 5)
    }
    //5)
    public static KeyframeSet ofFloat(float... values) {
        boolean badValue = false;
        //参数是可变参数，那么先确定传入的参数的数量大小
        int numKeyframes = values.length;
        //构建关键帧的数量，至少是两个关键帧(开始与结束)
        FloatKeyframe keyframes[] = new FloatKeyframe[Math.max(numKeyframes,2)];
        //当传入参数只有一个值时，默认这个值时结束帧的值，然后默认构建一个开始帧的值，且为0
        if (numKeyframes == 1) {
            keyframes[0] = (FloatKeyframe) Keyframe.ofFloat(0f);//开始帧
            keyframes[1] = (FloatKeyframe) Keyframe.ofFloat(1f, values[0]);//结束帧
            if (Float.isNaN(values[0])) {
                badValue = true;
            }
        } else {
            //构建多帧的情况,（多帧时区间的比列是均分的）
            //所谓的比列就是Keyframe.ofFloat(float fraction, float value) 的 fraction 值
            // eg: 入参是 （0,20,50,0）
            // 那么就会创建4个关键帧
            // fraction的值分别是： 0, 1/3, 2/3, 3/3
            keyframes[0] = (FloatKeyframe) Keyframe.ofFloat(0f, values[0]);//开始帧 （第一帧）
            for (int i = 1; i < numKeyframes; ++i) {
                keyframes[i] =
                        (FloatKeyframe) Keyframe.ofFloat((float) i / (numKeyframes - 1), values[i]);
                if (Float.isNaN(values[i])) {
                    badValue = true;
                }
            }
        }
        if (badValue) {
            Log.w("Animator", "Bad value (NaN) in float animator");
        }
        return new FloatKeyframeSet(keyframes);//5-1)
    }
    //5-1) 因为是float类型的值所以使用 KeyframeSet的子类  FloatKeyframeSet
    //但是初始化值时还是使用的基类的构造方法
    public KeyframeSet(Keyframe... keyframes) {
        mNumKeyframes = keyframes.length;
        // immutable list
        mKeyframes = Arrays.asList(keyframes);
        mFirstKeyframe = keyframes[0];//开始帧
        mLastKeyframe = keyframes[mNumKeyframes - 1];//结束帧
        mInterpolator = mLastKeyframe.getInterpolator();//插值器 它的来源?
    }
```
```text
    //关键帧 在属性动画中的使用体现 是在 ValueAnimator.animateValue()方法中
    // ValueAnimator.animateValue的逻辑可以参看[属性动画]的流程分析
    public Object getValue(float fraction) {
        // Special-case optimization for the common case of only two keyframes
        if (mNumKeyframes == 2) {
            if (mInterpolator != null) {
                fraction = mInterpolator.getInterpolation(fraction);
            }
            return mEvaluator.evaluate(fraction, mFirstKeyframe.getValue(),
                    mLastKeyframe.getValue());
        }
        if (fraction <= 0f) {
            final Keyframe nextKeyframe = mKeyframes.get(1);
            final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
            if (interpolator != null) {
                fraction = interpolator.getInterpolation(fraction);
            }
            final float prevFraction = mFirstKeyframe.getFraction();
            float intervalFraction = (fraction - prevFraction) /
                (nextKeyframe.getFraction() - prevFraction);
            return mEvaluator.evaluate(intervalFraction, mFirstKeyframe.getValue(),
                    nextKeyframe.getValue());
        } else if (fraction >= 1f) {
            final Keyframe prevKeyframe = mKeyframes.get(mNumKeyframes - 2);
            final TimeInterpolator interpolator = mLastKeyframe.getInterpolator();
            if (interpolator != null) {
                fraction = interpolator.getInterpolation(fraction);
            }
            final float prevFraction = prevKeyframe.getFraction();
            float intervalFraction = (fraction - prevFraction) /
                (mLastKeyframe.getFraction() - prevFraction);
            return mEvaluator.evaluate(intervalFraction, prevKeyframe.getValue(),
                    mLastKeyframe.getValue());
        }
        Keyframe prevKeyframe = mFirstKeyframe;
        for (int i = 1; i < mNumKeyframes; ++i) {
            Keyframe nextKeyframe = mKeyframes.get(i);
            if (fraction < nextKeyframe.getFraction()) {
                final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
                final float prevFraction = prevKeyframe.getFraction();
                float intervalFraction = (fraction - prevFraction) /
                    (nextKeyframe.getFraction() - prevFraction);
                // Apply interpolator on the proportional duration.
                if (interpolator != null) {
                    intervalFraction = interpolator.getInterpolation(intervalFraction);
                }
                return mEvaluator.evaluate(intervalFraction, prevKeyframe.getValue(),
                        nextKeyframe.getValue());
            }
            prevKeyframe = nextKeyframe;
        }
        // shouldn't reach here
        return mLastKeyframe.getValue();
    }
```