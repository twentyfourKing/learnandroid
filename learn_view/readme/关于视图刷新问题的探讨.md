探讨
===
在view类中触发视图刷新的方法有requestLayout和invalidate。

听说 ：requestLayout会执行视图刷新流程中的测量、布局、绘制；而invalidate只会触发绘制操作，是这样的吗？

同时伴随的问题还有：

1、invalidate()方法怎样触发某个view的绘制？

2、某个view执行invalidate()与它父布局执行invalidate()有什么区别？

3、在一个父布局中有多个view，只有其中某个view激活invalidate()，那么其他view会有什么影响?

我们通过代码进行一些猜想逻辑测试，再去根据源码找到蛛丝马迹。

tips：在例子中，我们定义3个自定义view

MyLinearLayout1 继承于 LinearLayout

MyTextView1 继承于 TextView

MyTextView2 继承于 TextView

它们都分别覆写了 View类的 onMeasure 、onLayout 、onDraw

情景1：app启动，加载界面视图时,如下log信息。

结论：验证了我们之前分析视图绘制流程，绘制流程是先后经历测量、布局、绘制。
测量的过程是从view树的顶层开始，依次遍历view树，调用各自的onMeasure方法。
布局的逻辑流程也是一样的，从顶层开始到最后的view。最后是绘制。

```text
    D/test_for_view: MyLinearLayout1 --> onMeasure
    D/test_for_view: MyTextView1 --> onMeasure
    D/test_for_view: MyTextView2 --> onMeasure
    D/test_for_view: MyLinearLayout1 --> onMeasure
    D/test_for_view: MyTextView1 --> onMeasure
    D/test_for_view: MyTextView2 --> onMeasure
    
    D/test_for_view: MyLinearLayout1 --> onLayout
    D/test_for_view: MyTextView1 --> onLayout
    D/test_for_view: MyTextView2 --> onLayout
    
    D/test_for_view: MyTextView1 --> onDraw
    D/test_for_view: MyTextView2 --> onDraw
```
> 情景2：对应测试逻辑1

MyTextView1执行invalidate()。前置条件（TextView1未改变自身的任何属性）

```text
    D/test_for_view: MyTextView1 --> onDraw
```

> 情景3：对应测试逻辑2

执行MyLinearLayout1的invalidate()。前置条件（MyLinearLayout1自身属性未改变，
它的子view：MyTextView1 , MyTextView2的属性也未做改变）

```text
    没有任何的log输出
```
> 情景4: 对应测试逻辑3

改变了MyLinearLayout1的背景色
```text
    D/test_for_view: MyLinearLayout1 --> onMeasure
    D/test_for_view: MyLinearLayout1 --> onLayout
    D/test_for_view: MyLinearLayout1 --> onDraw
```
> 情景5： 对应测试逻辑4

改变MyTextView1的字体颜色。前置条件（MyLinearLayout1未做任何改变）

```text
    D/test_for_view: MyTextView1 --> onDraw
```

> 情景6: 对应测试逻辑5

改变了MyTextView1的宽值，而且该值可能会引起父布局改变。

结论：因为MyTextView1的大小引起了布局的改变，所以其父布局执行了测量，并测量了所有子view，
并重新安排布局，但是绘制的对象还是只有MyTextView1。

```text
    D/test_for_view: MyLinearLayout1 --> onMeasure
    D/test_for_view: MyTextView1 --> onMeasure
    D/test_for_view: MyTextView2 --> onMeasure
    D/test_for_view: MyLinearLayout1 --> onLayout
    D/test_for_view: MyTextView1 --> onLayout
    D/test_for_view: MyTextView2 --> onLayout
    D/test_for_view: MyTextView1 --> onDraw
```

综合以上5个测试逻辑（1-5）我们可以得出这样的一个逻辑:

> invalidate()方法本身的逻辑流程只是为了重绘申请重绘的这个view，理论上只会执行绘制操作。
但是当申请的这个view有大小变化，同时这个大小变化会影响到父布局和其他子view时，
那么还是会从父布局进行测量得到新的大小，并且安排新的布局，但最后还是只有申请的这个view才会执行绘制。

> 情景7： 对应测试逻辑6

MyTextView1 执行了requestLayout().前置条件（父布局未改变，MyTextView1未做改变）
```text
    D/test_for_view: MyLinearLayout1 --> onMeasure
    D/test_for_view: MyTextView1 --> onMeasure
    D/test_for_view: MyLinearLayout1 --> onLayout
    D/test_for_view: MyTextView1 --> onLayout
    D/test_for_view: MyTextView1 --> onDraw
```
> 情景8： 对应测试逻辑7

MyLinearLayout1 执行requestLayout()。前置条件（MyLinearLayout1 未做其他改变，子view也没有变化）

```text
    D/test_for_view: MyLinearLayout1 --> onMeasure
    D/test_for_view: MyLinearLayout1 --> onLayout
```

> 情景9： 对应测试逻辑8

MyLinearLayout1  改变了宽值，然后执行requestLayout()。

```text
    D/test_for_view: MyLinearLayout1 --> onMeasure
    D/test_for_view: MyTextView1 --> onMeasure
    D/test_for_view: MyTextView2 --> onMeasure
    D/test_for_view: MyLinearLayout1 --> onLayout
    D/test_for_view: MyTextView1 --> onLayout
    D/test_for_view: MyTextView2 --> onLayout
```
综合以上3个测试逻辑（6-8）我们可以得出这样的一个逻辑:

> requestLayout()方法的执行流程上，是会经历 测量、布局、绘制的。
但是如果有些父布局并未还有任何改变，那么就不会执行绘制。如果要执行绘制，
那也只会是申请requestLayout()的这个view，具有同一个父布局的其他子view，
会参与测量或者布局，但是不会执行绘制。

上面提出的猜想和问题，在上面的测试逻辑进行了验证。
最后执行流程到底是怎样的呢？绘制是怎样被标记呢？

我们看下[requestLayout和invalidate的源码流程分析](https://github.com/twentyfourKing/learnandroid/blob/master/learn_view/readme/requestLayout和invalidate的源码流程分析.md)






